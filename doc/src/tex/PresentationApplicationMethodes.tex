\chapter{Application des méthodes au problème}
    Dans cette partie, nous allons présenter comment les diverses techniques que nous souhaitons appliquer sont compatibles avec notre cas spécifique du sudoku.
    \section{A*}

 \textit{Cette partie présente l'application de l'algorithme au problème du Sudoku, dans le cas d'une grille de dimension 9 par 9.}
   
\textit{   Rappel : la``région'' d'une case correspond aux autres cases de sa ligne, sa colonne et son bloc.
   }
     
  \subsection{Construction du graphe}
    
   
    Comme vu précédemment, l'algorithme A* est un algorithme de recherche de plus court chemin dans un graphe. Plus précisément dans le cas du Sudoku, on construit un graphe ayant pour racine la \textbf{grille initiale}, avec seulement les indications de départ.
    
    Chaque sommet correspond ensuite à un état de la grille, parmi lesquels on avance en ajoutant un chiffre dans une case vide. On va donc de case en case jusqu'à ce que la grille soit complète ou que l'on ai trouvé une erreur, au quel cas on retourne en arrière et on retente une autre possibilité.
    
   On a donc un graphe $G = (V,E)$, où : 
   
\begin{description} 
\item[V, pour vertices,] est l'ensemble des sommets ou encore des états de la grille.

 \item[E, pour edges,] est l'ensemble des arrêtes, chacune constituée d'une paire d'éléments de $V$. \textit{Une arrête ``ajoute'' permet de passer de grille en grille en ajoutant un chiffre à une case vide...}

\end{description}
    
            \bigskip
            Sans revenir sur l'algorithme lui même, il est tout de même nécessaire de préciser certains points : l'algorithme utilise \textbf{deux listes}, une dites \textit{fermée} et l'autre \textit{ouverte}. La liste ouverte contient toutes les grilles qui ont été évaluées mais pas développées. La liste fermée contient quand à elle l'ensemble des grilles qui ont été étudiées.
            
            Pour déterminer quel chemin emprunter l'algorithme calcul un \textbf{coût} $F$ pour chaque sommet et en cherche le minimum à chaque étape. \textit{Remarque : on calcule le coût de chaque successeur c'est à dire en remplissant une case vide avec un chiffre entre 1 et 9 afin de déterminer laquelle est ``optimale'' pour continuer la recherche.} Le coût $F$ est déterminé comme la somme d'une fonction coût $G$ et d'une heuristique $H$. C'est deux fonctions sont à déterminer en fonction du problème.
            \bigskip
            
            Cette application de l'algorithme présente cependant quelques particularités : en effet, cette application ne nécessite ni état final ni graphe à parcourir. Le graphe est construit au fur et mesure que l'algorithme cherche des voisins. \textit{Construire le graphe revient à résoudre le sudoku.} D'autre part, l'état final n'est pas un nœud du graphe, mais plutôt n'importe quel nœud qui correspond à un Sudoku rempli et sans doublon.
            
            
              Tant que l'on a pas trouvé de solution ou que l'on ai testé toute les grilles possibles, l'algorithme va :
            \begin{itemize}
            	  \item choisir le Sudoku de la liste ouverte possédant le plus petit coût F,
               \item créer des grilles à partir de la grille choisie et d'une des valeurs possibles pour l'une des cases vides celle ci,
                \item vérifier la présence de doublon dans les nouvelles grilles,
                \item vérifier si ces grilles ont déjà été étudiées \textit{(Se trouvent elles déjà dans la liste fermée ?)},
                \item le cas échéant, chaque nouvelle grille se voit mettre à jour les valeurs possibles de ses cases vides et on calcule les nouvelles valeurs de G et H,
                \item enfin, on ajoute ces grilles à la liste ouverte, et on recommence la recherche de la grille possédant le plus petit coût...   
            \end{itemize}
        \subsection{Choix des fonctions coût}
        
            On peut choisir différentes fonction coût pour le problème du Sudoku, ce choix va bien sur affecté le temps de calcul de l'algorithme.
            \subsubsection*{La fonction G}
            
                L'une des façons la plus simple de l'estimer est de prendre le nombre de cases remplies dans la grille. En effet, moins il y a de case vide, plus il sera simple de déterminer une valeur et plus on se rapproche d'une grille remplie.
                
            \subsubsection*{L'heuristique H}
            

 
 	C'est principalement le choix de l'heuristique qui influe sur l'efficacité de l'algorithme : nous avons choisi un fonction qui renvoie la somme du nombre de valeurs possibles de chaque case vide d'une grille donnée. On va donc devoir mettre à jour les valeur possibles de la grille pour calculer son heuristique.
 	Le nombre de possibilités pour une case vide est déterminé en fonction des règles du Sudoku et des cases remplies qui se trouvent dans la même région \textit{(ligne, colonne, et bloc)}.
 	Cette fonction donne une assez bonne idée de la ``distance'' qui éloigne une grille d'une grille remplie. En effet, c'est une indication du nombre de grille que l'algorithme devra construire pour développer une grille. 

               \textit{Remarque : dans le cas où il n'y a aucune possibilité pour une case donnée, c'est que la grille contient au moins un doublon. On peut donc aussi se servir de cette information pour enlever des grilles de la liste ouverte.}
 

	    \subsection{Exemple}




Voyons au travers d'un exemple le fonctionnement de l'algorithme. Nous partirons de la grille suivante :

\begin{center}
\includegraphics[scale=0.5]{images/AStarExample/ini.png}
\end{center}

Pour initialiser l'algorithme on doit mettre à jour les possibilités et calculer les valeurs de G et de H correspondante à la première grille. \textit{On note en bleu le nombre de possibilités pour une case donnée.}

\begin{center}
\includegraphics[scale=0.4]{images/AStarExample/ini_H.png}
\end{center}

On imagine à présent que l'algorithme parcourt les cases de la grille de gauche à droite, puis de haut en bas. Il va construire toutes les grilles possibles, en fonction des valeurs encore disponible. Pour le bien de l'exemple, nous avons construit les quatre premières grilles que l'algorithme va construire : \textit{(on peut voir le chiffre ajouté en rouge)}

\begin{center}
\includegraphics[scale=0.3]{images/AStarExample/1_1.png}
\includegraphics[scale=0.3]{images/AStarExample/1_2.png}

\includegraphics[scale=0.3]{images/AStarExample/1_3.png} 
\includegraphics[scale=0.3]{images/AStarExample/1_4.png}
\end{center}

On vérifie alors, dans les grilles ainsi construites, qu'il y ai pas de case vide ne possédant aucune valeur possible. \textit{Il n'est pas possible de remplir ces cases, on élimine donc ces grilles.}

On ajoute les grilles restantes à la liste ouverte. On calcul les valeurs de G et de H correspondantes à chaque grille et l'algorithme va choisir celle qui à la plus petite valeur pour la somme $F = G+H$.

Dans ce cas, l'algorithme construit 142 grilles, et choisi parmi celles-ci la grille suivante \textit{(la valeur ajoutée est notée en vert)}:

\begin{center}
\includegraphics[scale=0.3]{images/AStarExample/1.png}
\end{center}


Il va ensuite recommencer la création de 127 grilles à partir de la grille choisie, et choisir la prochaine grille à développer...


\begin{center}
\includegraphics[scale=0.3]{images/AStarExample/2_1.png}
\includegraphics[scale=0.3]{images/AStarExample/2_2.png}


\includegraphics[scale=0.3]{images/AStarExample/2.png}
\end{center}


L'algorithme continue la recherche de grille à développer jusqu'à ce qu'il soit arriver à une grille où $H=0$, ce qui correspond à une grille complète \textit{(on sait aussi que l'algorithme ne construit pas de grille possédant de doublon)}; ou jusqu'à ce qu'il ai parcourut \textbf{toutes} les grilles possibles mais qu'il n'a pas trouver de grille complète. Le problème n'a alors pas de solution.



         \subsection{Implémentation}
         
                 
            \subsubsection{Diagrammes de classe}
            
            \textit{Dans les diagrammes de classe qui suivent, les attributs privés sont accessibles à l'aide de méthodes get et set.}
            
            \begin{description}
            	\item[La classe Sudoku] :
            
                \begin{center}
                    \includegraphics[scale = 0.5]{images/Sudoku_classe.png}	
                \end{center}
                \bigskip
                
                Un \textbf{Sudoku} est composé d'une grille, une liste de $taillle^2$ Cells qui sont rangées dans un tableau à deux dimensions. 
                
                Chaque \textbf{Cell} contient un \textbf{Number} qui pour cette application n'est un simple entier. On ajoute une liste d'entier pour maintenir la liste des valeurs possibles de cette cases \textit{remainingValues} ainsi qu'une liste de pointeurs sur Cell \textit{adjacentCells} qui permet de retrouver les cases appartenant à la même \textit{région} que celle-ci.
                
                La classe Cell dispose d'une méthode \textit{updatePossibility()} qui met à jour la liste \textit{remainingValues} en considérant les valeurs des cases remplies contenues dans \textit{adjacentCells}
                
                La classe Sudoku contient plusieurs méthodes utiles : 
                
\begin{itemize}
\item \textit{DéfinirRégion()}, qui l'on appelle dans les constructeurs de la classe, et qui, pour chaque Cell, va remplir la liste \textit{adjacentCells} des cases contenues dans la même région.

\item \textit{UpdatePossibility()}, qui met à jour les possibilités de toutes les cases de la grilles, en appelant la méthode correspondante de chaque Cell.

\textit{On peut aussi utiliser une version plus ``légère'' de cette méthode, en lui passant en argument une Cell et en ne mettant à jour que les cases contenues dans sa région. En effet, puisque l'on remplit les cases une par une, seules les valeurs possibles des cases de la  même région modifiée sont à mettre à jour.}

\item La fonction \textit{CheckDouble()} teste si le Sudoku n'est pas erroné et renvoie un booléen. On peut tester, pour chaque cases de la grille, que se valeur n'apparaît qu'une seule fois \textit{région}.

\textit{On peut, et on préférera, simplement vérifier que l'on ne construit pas de grille où l'une des cases vides n'a aucune valeur possible, ce qui nous permet de vérifier les grilles en même temps que l'on calculera la valeur de H.}

\end{itemize}
                
                
                
                
                
                \item[A*] :
 
 Voici le diagramme de classe de l'algorithme A* dans le cas d'un graphe dans lequel on recherche un chemin.
 
 \begin{center}
                \includegraphics[scale=0.5]{images/Astar_classe.png}               
              
              \end{center}
              
Sans s'attarder sur celui-ci, considérons le diagramme correspondant à un cas plus ``général'', et que l'on peut appliquer au Sudoku. L'idée de généraliser les classes Noeud et Graphe et d'en faire hériter des classes depuis lesquelles on pourra adapter l'algorithme au problème étudié.

\textit{La classe Sudoku est celle présentée précédemment, on ne réécrit cependant pas les classe s Cell et Number pour gagner en  lisibilité...}

\begin{center}
\includegraphics[scale = 0.5]{images/Astar_sudoku_classe.png}
\end{center}



La classe \textbf{Graphe} contient une liste de pointeur sur Noeud, ainsi qu'une fonction \textit{ virtuelle} qui permet de calculer la distance entre deux Noeud du graphe. Cette fonction est utilisé pour le test d'arrêt de l'algorithme, en comparant la distance entre le Noeud \textit{courant} et le Noeud \textit{final}.

La fonction \textit{Distance()} est virtuelle afin que l'on puisse redéfinir le calcul de la distance conformément au problème étudié. Pour le Sudoku, on fait hériter la classe \textbf{Sudokus} de la classe Graphe, et on redéfinit la fonction \textit{Distance()} pour qu'elle ne renvoie que la valeur  de H du Noeud \textit{(Sudoku)} courant.


Pour pouvoir généraliser  l'algorithme, la classe \textbf{Noeud} doit être définit comme une classe \textit{abstraite}, c'est la raison pour laquelle on utilise des pointeurs lorsque l'on a besoin d'une référence à un Noeud.

Un Noeud contient donc des références à ses Noeuds \textit{parents} et \textit{enfants}, ainsi que deux entiers qui contiennent les valeurs de G et de H. On ajoute aussi une chaîne de caractères \textit{nodeID} qui nous permettra de définir \textbf{l'égalité} de deux Noeuds avec l'égalité de leur \textit{nodeID}. \textit{L'égalité de deux Noeuds nous permet de vérifier si on a déjà parcourut un Noeud.} De plus, on définit un \textbf{opérateur de comparaison} de deux Noeuds, qui renvoit le Noeud possédant la plus petite valeur de $G+H$.

\textit{Remarque : en $C++$, la définition d'un tel opérateur demande l'utilisation d'une classe Compare indépendante de la classe Sudoku, ne possédant que la fonction de comparaison.}

La classe Noeud contient les méthodes virtuelles pures suivantes :
\begin{itemize}
\item \textit{updateGH()} qui calcul les valeurs de G et de H du Noeud. Cette méthode est bien sur virtuelle puisque le calcul dépend directement du problème.

\item La fonction \textit{createID()} permet de construire la chaîne de caractères \textit{nodeID} permettant de tester l'égalité plus facilement.

\item La fonction \textit{getVoisins()} renvoit la liste des Noeuds voisins du Noeud dans le Graphe. Cette fonction est virtuelle car pour certains problèmes, comme le Sudoku, on ne veut pas donner un graphe à étudier à l'algorithme, mais plutôt le laisser construire le graphe au fur et à mesure de sa recherche. Pour cela, on pourra définir dans cette méthode si l'algorithme parcourt un graphe, ou comment il doit construire les Noeuds à développer.

\end{itemize}

On fait donc hériter la classe \textbf{Sudoku} de la classe Noeud, et on redéfinit les méthodes et fonctions virtuelles précédentes.

\begin{itemize}

\item \textit{updateGH()} fixe les valeurs de G et de H à 0, puis parcourt toutes les cases de la grille. Si une case est remplie, elle ajoute un à G, sinon elle met à jour ses valeurs possibles ajoute le nombre de valeurs possibles à H.

\textit{On profite de la mise à jour des valeurs possibles pour tester si la grille n'est pas erronée.}

\item \textit{CreateID()} construit une chaîne de caractères composée des chiffres (ou nombres) de la grille, séparés par un symbole $\$$. On peut ainsi considérer des grilles utiliser les nombres supérieurs à 9 \textit{(comme un Sudoku de dimension 16 par 16)}.


\item \textit{getVoisins()} va \textbf{construire} tout les voisins possibles d'un Sudoku, c'est à dire toute les grilles que l'on peut construire à partir de celui-ci en remplissant une de ses cases vides avec l'une des \textbf{valeurs possibles}. La fonction appelle pour chaque voisin construit la méthode \textit{updateGH()}, ce qui élimine les grilles erronées et met à jour les possibilités, les valeurs de G et de H. Les Sudokus ainsi renvoyés son prêt à être triés et développer par l'algorithme, il suffit de les ajouter à la liste ouverte, si il n’apparaissent pas déjà dans la liste fermée \textit{(on utilise les nodeID)}.

\end{itemize}
              

          \end{description}  
              
 
    \section{Algorithme génétique}
        Pour spécifier notre instance générale d'algorithme génétique, nous avons 4 éléments à définir:
        \begin{itemize}
            \item Les génomes
            \item La sélection des meilleurs génomes
            \item Le croisement de différents génomes
            \item La mutation d'un génome
        \end{itemize}
        Pour certains de ces éléments, il peut exister différentes manières de procéder, nous allons donc en détailler plusieurs.
        \subsection{Génomes}
            Dans un premier temps, il nous faut nous poser la question de comment représenter notre grille de sudoku sous un format propice à un algorithme génétique.\\
            \subsubsection{Méthode 1D}
                Dans beaucoup de cas, travailler sur un tableau à une dimension simplifie énormément le travail. Nous allons donc procéder comme suit:
                \begin{description}
                    \item[Grille sudoku vide]:\\
                        \begin{center}
                            \begin{tabular}{|c|c|c| |c|c|c| |c|c|c|}
                                \hline
                                &\textbf{1}&&&&\textbf{3}&&&\\
                                \hline
                                &&&\textbf{4}&&&&&\\
                                \hline
                                &&&&\textbf{2}&&&&\\
                                \hline
                                \hline
                                &&&\textbf{7}&&&&&\\
                                \hline
                                \textbf{8}&&&&&&&\textbf{6}&\\
                                \hline
                                &&\textbf{5}&&&&&&\\
                                \hline
                                \hline
                                &&&&\textbf{3}&&&&\textbf{9}\\
                                \hline
                                &\textbf{3}&&&&&\textbf{1}&&\\
                                \hline
                                &&&&\textbf{6}&&&&\\
                                \hline
                            \end    {tabular}
                        \end{center}
                    \item[G\'enome]: Un tableau d'une dimension contenant uniquement le contenu des cases \textbf{non données} dans l'énonce.
                \end{description}
            \subsubsection{Méthode 2D}
                Cependant il subsiste des cas où il est important de garder l'aspect 2D pour faciliter les traitements qui seront fait dessus par la suite.\\
                Dans ces cas ci, on garde un tableau 2D de ``cases'', qui seront une pair contenant une valeur, et si cette case est donnée dans l'énoncé
        \subsection{Sélection}
            La sélection est une étape qui ne devrait pas être trop complexe.\\
            Le but serait d'affecter à chaque grille un \textbf{score}, tel que le score ``parfait'' corresponde à la une grille complétée, et plus la grille serait ``résolue'', plus le score serait élevé, plus la grille serait proche de la résolution.\\

            Une fois ce score obtenu, il nous suffira de prendre la \textbf{meilleure moitié} de la génération actuelle (Ceux dont le score est le plus élevé).\\

            Sachant que une grille résolue est une grille ``Avec 9 chiffres différents par ligne, colonne, et bloc''.\\
            Nous allons donc définir le score comme étant la somme du nombre de chiffres différents par lignes, colonnes, et blocs.

            \begin{center}
                \begin{tabular}{rcl}
                    \textbf{Score}&=&$\sum_{i=1}^9$\textbf{nombre numéros différents dans ligne i}\\
                        &+&$\sum_{i=1}^9$\textbf{nombre numéros différents dans colonne i}\\
                        &+&$\sum_{i=1}^9$\textbf{nombre numéros différents dans bloc i}
                \end{tabular}
            \end{center}
        \subsection{Croisement}
            Le croisement des génomes sélectionnés est la méthode la plus importante de tout l'algorithme, car c'est la méthodes qui sera en charge de ``passer'' les gains d'information précédents aux nouveaux génomes.\\
            Il parait normal que le croisement ne soit pas réalisé tout le temps, c'est la raison pour laquelle nous allons imposer un \textbf{taux de croisement}.\\
            Ce taux ($0\leq taux\leq 1$) est défini par l'utilisateur, et représente le pourcentage de chance qu'une paire de génomes se croise.\\

            Nous commençons par diviser d'intégralité des génomes sélectionnés en \textbf{paires distinctes de génomes}.\\
            Cela nous évitera que le même génome se retrouve plusieurs fois au sein de croisement.\\

            Deux méthodes peuvent être employées pour le croisement:
            \begin{itemize}
                \item Croisement naïf
                \item Croisement optimisé
            \end{itemize}
            \subsubsection{Croisement naïf}
                Ce croisement utilise un génome basé sur le modèle 1D.\\
                Le but de ce dernier est de fonctionner rapidement, et à défaut d'être efficace rapidement, il utilise l'aléatoire pour favoriser un mélange hétéroclite sur plusieurs générations.\\
                \subsubsubsection{Fonctionnement}
                    Donnons nous 2 génomes tirés aléatoirement parmi ceux sélectionnés lors de la phase précédente.\\
                    \begin{description}
                        \item[Genome 1]:\\
                            \[
                                \begin{array}{|c|c|c|c|c|c|c|c|c|c|}
                                    \hline
                                    g_1&g_2&g_3&g_4&g_5&g_5&g_6&\cdots&g_{n-1}&g_{n}\\
                                    \hline
                                \end{array}
                            \]
                        \item[Genome 2]:\\
                            \[
                                \begin{array}{|c|c|c|c|c|c|c|c|c|c|}
                                    \hline
                                    h_1&h_2&h_3&h_4&h_5&h_5&h_6&\cdots&h_{n-1}&h_{n}\\
                                    \hline
                                \end{array}
                            \]
                    \end{description}

                    L'algorithme sélectionne alors un nombre k tel que: $1\leq k\leq n$.\\
                    Ce nombre servira de point de séparation pour les deux génomes.
                    \begin{description}
                        \item[Genome 1]:\\
                            \[
                                \begin{array}{|c|c|c|c|c|c|c|c|c|c|}
                                    \hline
                                    g_1&g_2&g_3&\cdots&g_{k-1}&g_k&g_{k+1}&\cdots&g_{n-1}&g_{n}\\
                                    \hline
                                \end{array}
                            \]
                        \item[Genome 2]:\\
                            \[
                                \begin{array}{|c|c|c|c|c|c|c|c|c|c|}
                                    \hline
                                    h_1&h_2&h_3&\cdots&h_{k-1}&h_k&h_{k+1}&\cdots&h_{n-1}&h_{n}\\
                                    \hline
                                \end{array}
                            \]
                    \end{description}

                    En croisant les deux moitiés, nous pouvons donc créer deux nouveau génomes reprenant les gènes des parents.
                    \begin{description}
                        \item[Nouveau genome 1]:\\
                            \[
                                \begin{array}{|c|c|c|c|c|c|c|c|c|c|}
                                    \hline
                                    g_1&g_2&g_3&\cdots&g_{k-1}&g_k&h_{k+1}&\cdots&h_{n-1}&h_{n}\\
                                    \hline
                                \end{array}
                            \]
                        \item[Nouveau genome 2]:\\
                            \[
                                \begin{array}{|c|c|c|c|c|c|c|c|c|c|}
                                    \hline
                                    h_1&h_2&h_3&\cdots&h_{k-1}&h_k&g_{k+1}&\cdots&g_{n-1}&g_{n}\\
                                    \hline
                                \end{array}
                            \]
                    \end{description}
                \subsubsubsection{Inconvénients}
                    Malheureusement, aussi simple soit elle, elle est loin d'être la meilleure.\\
                    En effet, elle prend de manière anarchique et aléatoire les gènes des parents. Comment être sûr de ce que nous avons pris?\\
                    Ce qui faisait le ``haut score'' des parents se retrouvera peut être détruit par ce croisement (Modification d'une ligne, colonne ou bloc qui était résolu)
            \subsubsection{Croisement optimisé}
                Pour palier à cette perte d'information, nous allons mettre en place une autre méthodologie.\\
                Et si au lieu de croiser naïvement, nous faisions attention à préserver des parties intéressantes?
                \subsubsubsection{Pré-requis}
                    Nous allons donc faire un croisement qui part d'une supposition simple:\\
                    \begin{center}
                        Tous les génomes sont valides pour les blocs
                    \end{center}
                    Générer une première génération respectant cette condition est relativement facile (Pour chaque bloc, regarder les nombres pas encore placés, et les mettre 1 par case vide).\\
                    Il faudra juste faire attention à préserver cette propriété lors du croisement.
                    Le croisement se fera sur un modèle 2D, pour garder cette idée de correct du point de vue des blocs.\\
                \subsubsubsection{Mise en place}
                    Le croisement sélectionnera au hasard 2 génomes parmi les parents, et en calculera un ``score'' de ligne et colonne:\\
                    \begin{description}
                        \item[Parent 1]:\\
                            \begin{center}
                                \begin{tabular}{|c|c|c| |c|c|c| |c|c|c| |l}
                                    \hline
                                    X&\textbf{G}&X&X&X&\textbf{G}&X&X&X&$\rightarrow l_1$\\
                                    \hline
                                    X&X&X&\textbf{G}&X&X&X&X&X&$\rightarrow l_2$\\
                                    \hline
                                    X&X&X&X&\textbf{G}&X&X&X&X&$\rightarrow l_3$\\
                                    \hline
                                    \hline
                                    X&X&X&\textbf{G}&X&X&X&X&X&$\rightarrow l_4$\\
                                    \hline
                                    \textbf{G}&X&X&X&X&X&X&\textbf{G}&X&$\rightarrow l_5$\\
                                    \hline
                                    X&X&\textbf{G}&X&X&X&X&X&X&$\rightarrow l_6$\\
                                    \hline
                                    \hline
                                    X&X&X&X&\textbf{G}&X&X&X&\textbf{G}&$\rightarrow l_7$\\
                                    \hline
                                    X&\textbf{G}&X&X&X&X&\textbf{G}&X&X&$\rightarrow l_8$\\
                                    \hline
                                    X&X&X&X&\textbf{G}&X&X&X&X&$\rightarrow l_9$\\
                                    \hline
                                    \hline
                                    $\downarrow$&$\downarrow$&$\downarrow$&$\downarrow$&$\downarrow$&$\downarrow$&$\downarrow$&$\downarrow$&$\downarrow$&\\
                                    $c_1$&$c_2$&$c_3$&$c_4$&$c_5$&$c_6$&$c_7$&$c_8$&$c_9$&\\
                                \end{tabular}
                            \end{center}
                        \item[Parent 2]:\\
                            \begin{center}
                                \begin{tabular}{|c|c|c| |c|c|c| |c|c|c| |l}
                                    \hline
                                    Y&\textbf{G}&Y&Y&Y&\textbf{G}&Y&Y&Y&$\rightarrow l_1$\\
                                    \hline
                                    Y&Y&Y&\textbf{G}&Y&Y&Y&Y&Y&$\rightarrow l_2$\\
                                    \hline
                                    Y&Y&Y&Y&\textbf{G}&Y&Y&Y&Y&$\rightarrow l_3$\\
                                    \hline
                                    \hline
                                    Y&Y&Y&\textbf{G}&Y&Y&Y&Y&Y&$\rightarrow l_4$\\
                                    \hline
                                    \textbf{G}&Y&Y&Y&Y&Y&Y&\textbf{G}&Y&$\rightarrow l_5$\\
                                    \hline
                                    Y&Y&\textbf{G}&Y&Y&Y&Y&Y&Y&$\rightarrow l_6$\\
                                    \hline
                                    \hline
                                    Y&Y&Y&Y&\textbf{G}&Y&Y&Y&\textbf{G}&$\rightarrow l_7$\\
                                    \hline
                                    Y&\textbf{G}&Y&Y&Y&Y&\textbf{G}&Y&Y&$\rightarrow l_8$\\
                                    \hline
                                    Y&Y&Y&Y&\textbf{G}&Y&Y&Y&Y&$\rightarrow l_9$\\
                                    \hline
                                    \hline
                                    $\downarrow$&$\downarrow$&$\downarrow$&$\downarrow$&$\downarrow$&$\downarrow$&$\downarrow$&$\downarrow$&$\downarrow$&\\
                                    $c_1$&$c_2$&$c_3$&$c_4$&$c_5$&$c_6$&$c_7$&$c_8$&$c_9$&\\
                                \end{tabular}
                            \end{center}
                    \end{description}
                    Où ``\textbf{G}'' représente un chiffre donné dans l'énoncé, et ou $l_x$ et $c_x$ représentent les scores de la ligne/colonne $x$.\\
                    $l_x$ et $c_x$ seront calculés comme le nombre d'éléments différents par ligne et colonne. Cela signifie donc que $1\leq l_x, c_x\leq 9$\\

                    Nous allons alors réunir les lignes et colonnes en lignes et colonnes de blocs.
                    \begin{description}
                        \item[Parent 1]:\\
                            \begin{center}
                                \begin{tabular}{|c|c|c| |l}
                                    \hline
                                    X&X&X&$\rightarrow L_1$\\
                                    \hline
                                    X&X&X&$\rightarrow L_2$\\
                                    \hline
                                    X&X&X&$\rightarrow L_3$\\
                                    \hline
                                    \hline
                                    $\downarrow$&$\downarrow$&$\downarrow$&\\
                                    $C_1$&$C_2$&$C_3$&\\
                                \end{tabular}
                            \end{center}
                        \item[Parent 2]:\\
                            \begin{center}
                                \begin{tabular}{|c|c|c| |l}
                                    \hline
                                    Y&Y&Y&$\rightarrow L_1$\\
                                    \hline
                                    Y&Y&Y&$\rightarrow L_2$\\
                                    \hline
                                    Y&Y&Y&$\rightarrow L_3$\\
                                    \hline
                                    \hline
                                    $\downarrow$&$\downarrow$&$\downarrow$&\\
                                    $C_1$&$C_2$&$C_3$&\\
                                \end{tabular}
                            \end{center}
                    \end{description}
                    Où $L_x=\sum_{i=x}^{i=x+2}l_i$ et $C_x=\sum_{i=x}^{i=x+2}c_i$.
                \subsubsubsection{Génération des fils}
                    En prenant nos 2 parents sous forme de ``grille de bloc'', nous allons générer deux fils:
                    \begin{itemize}
                        \item Le premier qui maximisera le score en ligne
                        \item Le second qui maximisera le score en colonne
                    \end{itemize}

                    Pour chaque ligne/colonne, l'algorithme regardera lequel des deux parents maximise le score de la ligne/colonne de bloc, et réutilisera cette ligne/colonne dans le fils.\\
                    Cela peut donc donner lieu à des fils comme suit.
                    \begin{description}
                        \item[Fils 1]:\\
                            \begin{center}
                                \begin{tabular}{|c|c|c| |l}
                                    \hline
                                    X&X&X&$\rightarrow L_{X,1}$\\
                                    \hline
                                    Y&Y&Y&$\rightarrow L_{Y,2}$\\
                                    \hline
                                    X&X&X&$\rightarrow L_{X,3}$\\
                                    \hline
                                    \hline
                                    $\downarrow$&$\downarrow$&$\downarrow$&\\
                                    $C_1$&$C_2$&$C_3$&\\
                                \end{tabular}
                            \end{center}
                        \item[Fils 2]:\\
                            \begin{center}
                                \begin{tabular}{|c|c|c| |l}
                                    \hline
                                    X&X&Y&$\rightarrow L_1$\\
                                    \hline
                                    X&X&Y&$\rightarrow L_2$\\
                                    \hline
                                    X&X&Y&$\rightarrow L_3$\\
                                    \hline
                                    \hline
                                    $\downarrow$&$\downarrow$&$\downarrow$&\\
                                    $C_{X,1}$&$C_{X,2}$&$C_{Y,3}$&\\
                                \end{tabular}
                            \end{center}
                    \end{description}

                    Ici, Fils 1 maximise en ligne (Et recalcule tous les $C_i$) alors que Fils 2 maximise en colonne (Et recalcule tous les $L_i$).\\

                    Pour refaire le parallèle avec les pré-requis, nos deux fils respectent la validité des blocs.
        \subsection{Mutation}
            Le but d'une mutation est de faire intervertir de ``nouvelles idées'' au sein des nouveaux génomes crées.\\
            Sans cette étape, il serait très fort probable que seul les mêmes ``gènes'' persistent au sein des générations, et ne permettent pas la résolution du problème.\\

            Si on prend l'exemple de notre cas du croisement optimisé, les blocs choisis ne changeraient pas au fil des générations, il est donc impossible de terminer le Sudoku si les 9 bonnes combinaisons de bloc n'existent pas dès le début.\\

            Comme pour les croisements, la mutation n'est pas forcée. Nous appliquons donc un \textbf{taux de mutation} qui correspond au pourcentage de chance que un de nos gènes mute.\\

            Comme précédemment, deux méthodes sont envisageables, applicables aux deux croisements précédents:
            \begin{itemize}
                \item Une mutation naïve
                \item Une mutation optimisée
            \end{itemize}
            \subsubsection{Mutation naïve}
                Une mutation simple consiste à prendre au hasard une case dans le Sudoku (Case qui ne serai pas donnée en énonce), et de lui affecter une valeur différente.\\
                Cette mutation est applicable uniquement au premier cas de croisement, sinon nous ne serions pas sûr de garder la validité de chacun des blocs.
            \subsubsection{Mutation optimisée}
                Une mutation plus adaptée au croisement optimisé est d'échanger deux chiffres au sein d'un bloc, qui sera choisi au hasard parmi les 9 blocs.\\
                Cette technique garde bien la validité des blocs, et permet de créer de nouveaux ``gènes''.\\

                Cependant, vaut-il mieux faire cette mutation dans tous les blocs? Ou bien seulement un bloc au hasard?\\
                Une autre solution serait d'utiliser le taux de mutation pour chacun des blocs.\\

                Une telle question tenant plus de l'expérimentation que de l'étude, nous affinerons les méthodes au cours de l'implémentation de l'algorithme.
        \subsection{Modélisation}
            \subsubsection{Diagramme de classes}
                Pour la modélisation, nous avons travaillé à partir du diagramme de classe suivant:
                \begin{center}
                    \includegraphics[scale=0.7]{diagrams/classesAlgoGenetique.png}
                \end{center}

                Il est important de noter que nous avons choisi de garder la généricité de l'algorithme en optant pour une interface IGenome.\\
                Cette interface sera implémentée par notre classe SudokuGenetique, mais dans le cadre d'un autre projet, il nous suffirait de reimplementer une autre classe.\\

                Si on étudie le diagramme de classes, on reconnait les 3 méthodes principale de sélection, croisement et mutation.\\
                On voit aussi la fonction fitnessScore() qui implémentera cette fonction score, et estSolution() qui sera la uniquement pour vérifier simplement si notre génome recoud le Sudoku.\\

                La boucle principale se fera sur l'objet ``AlgoGenetique'', qui bouclera sur ``genererNouvelleGeneration()'' tant qu'il n'existera pas de génome vérifiant le Sudoku.
            \subsubsection{Diagramme de séquences}
                Après s'être penchés sur l'algorithme, nous sommes parvenus à la réalisation de ce diagramme de séquences:
                \begin{center}
                    \includegraphics[scale=0.7]{diagrams/sequencesAlgoGenetique.png}
                \end{center}

                Si nous analysons le diagramme de séquences, nous pouvons lire les grandes lignes de l'algorithme:
                \begin{enumerate}
                    \item AlgoGenetique génère une population initiale, qui sera la génération 1.
                    \item Tant que le Sudoku n'est pas résolu (i.e. il existe un génome de score maximum), on génère une nouvelle population comme suit:
                        \begin{enumerate}
                            \item On récupère les meilleurs génomes selon leur fitnessScore
                            \item Pour tout couple de génomes parmi les meilleurs, on les croise.
                            \item Pour chacun des deux nouveaux génomes crées par le croisement, on les mute
                        \end{enumerate}
                \end{enumerate}
    \section{Eco-résolution}
        \subsection{Modélisation}
            Dans le chapitre, présentation des différents modèles nous avons présentés les divers attributs des eco-agents ainsi que leurs principales fonctions. \\
            L'éco-résolution est un mode de résolution utilisant plusieurs agents, la partie la plus complexe étant de définir quels sont nos agents et comment ils agissent entre eux. \\
            Nous avons ainsi défini le diagramme de classe suivant : \\
            \begin{center}
                \includegraphics[scale=0.7]{diagrams/ClasseEcoResolution1.png}
            \end{center} 
			
			Ce diagramme représente un schéma classique de l'éco-résolution. En effet, nous voyons que notre problème considéré comme éco-résoluteur a deux méthodes abstraites : estFini() et choixEcoAgent() qui seront redéfinies pour chacune des applications. 
			La méthode résolution est définie comme suit : 
					\begin{verbatim}
                        Procédure resolution() 
						tant que estFini()==false                        
                        		x=choixEcoAgent()
                        		essayerSatisfaire(x)
                    \end{verbatim}
            L'éco-Agent est défini comme vu dans la partie précédente.
                    
			\begin{center}
                \includegraphics[scale=0.7]{diagrams/ClasseEcoResolution2.png}
            \end{center} 
            
			Ce diagramme représente la modélisation de notre problème selon l'éco-résolution. Notre sudoku hérite de l'éco-résoluteur, nous retrouvons la estFini(), qui vérifie lorsque tous les éco-agents de notre système sont satisfaits et choixEcoAgent qui choisi a quel agent il donne la main (de manière aléatoire  dans un premier temps)\\			
            Avant de démarrer l'éco-résolution, nous allons compléter les cases vides de notre sudoku. Les cases étant déjà dans l'énoncé comporteront un attribut cellType valant "GIVEN". Pour remplir notre sudoku, nous allons effectué un remplissage "intelligent", c'est-à-dire que dans chaque bloc nous allons placer une et une seule fois chaque numéro de 1 à 9.\\
            Nos blocs étant déjà correctement rempli, nous avons choisi que nos cellules, nos lignes et nos colonnes seraient considérés comme éco-agent. \\
            
            \subsubsection{Les lignes}
                Nous allons voir les lignes comme éco-agent de la manière suivante : \\
                \begin{itemize}
                    \item Le but d'une ligne est que tous les éco-agents qui la compose (cellule) aient des numéros différents.
                    \item Pour trouver les gêneurs, cela correspondra à toutes les cellules qui ont un numéro qui intervient plus d'une fois. 
                    \item FaireSatisfaction : Passer l'état comme étant satisfait
                    \item une ligne ne pourra ni fuir, ni être en recherche de fuite.   
                \end{itemize}
            \subsubsection{Les colonnes}
                Nous allons voir les colonnes comme éco-agent de la manière suivante, analogue à la façon dont nous voyons les lignes : \\
                \begin{itemize}
                    \item Le but d'une colonne est que tous les éco-agents qui la compose (cellule) aient des numéros différents.
                    \item Pour trouver les gêneurs, cela correspondra à toutes les cellules qui ont un numéro qui intervient plus d'une fois. 
                    \item FaireSatisfaction : Passer l'état comme étant satisfait
                    \item une colonne ne pourra ni fuir, ni être en recherche de fuite.   
                \end{itemize}
            \subsubsection{Les cellules}
                Nous allons voir les cellules comme des agents de la manière suivante : 
                \begin{itemize}
                    \item Une cellule est satisfaite si sa ligne et sa colonne sont satisfaites
                    \item Les gêneurs d'une cellule sont les numéros ayant la même valeur sur la colonne et la ligne
                    \item Pour FaireSatisfaction d'une cellule, il faut qu'il n'y ai plus de gêneur
                    \item Pour trouverPlacePourFuir d'une cellule nous avons plusieurs idées : choisir une cellule aléatoirement dans le même bloc, choisir une cellule aléatoirement dans le bloc mais qui ne soit pas sur la ligne ou colonne de notre agent qui lance l'agression et enfin choisir la cellule qui a le plus de gêne.
                    \item Pour faireFuite, nous allons échanger les numéros de nos deux cellules.
                \end{itemize}
                
        \subsection{Exemple de déroulé de l'éco-résolution}
        
        	Nous allons présenté le déroulé de la résolution d'une grille de Sudoku par l'éco-résolution sur une grille 4*4.\\
        	Considérons la grille suivante comme étant notre point de départ.
        		\begin{center}
       			  \begin{tabular}{|c|c| |c|c| }
            			   \hline
            			   \textbf{1}&&&\\
            			   \hline
            			   &&\textbf{2}&\\
            	   		   \hline
               		   \hline
               		   &&&\\
                       \hline
               		   &\textbf{3}&&\textbf{4}\\                      
            			   \hline
        			 \end{tabular}
   			\end{center}
    
		
		La première étape consiste à remplir la grille. Pour cela nous remplissons chaque bloc de tel sorte que tous les numéros de 1 à 4 soient présents dans le bloc.
    
    		  \begin{center}
         		\begin{tabular}{|c|c| |c|c| }
             	 	  \hline
             	 	  \textbf{1}&2&1&3\\
             		  \hline
             		  3&4&\textbf{2}&4\\
             		  \hline
             		  \hline
             		  4&1&2&3\\
             		  \hline
             		  2&\textbf{3}&1&\textbf{4}\\                      
            			  \hline
        			\end{tabular}
    		\end{center}

	Ensuite nous rentrons dans la résolution a proprement parlé. Considérons le choix de la colonne 4 comme étant la colonne que l'on souhaite comme étant satisfaite (que des numéros différents présents sur cette colonne). \\
	Pour se faire la colonne trouve tous les gêneurs il s'agit des cellules (1,4), (2,4) et (3,4) car les numéros sont présents plus d'une fois dans la colonne mais ne sont pas donnés dans l'énoncé. \\
	Il faut ensuite choisir un agent parmi ces gêneurs à agresser par exemple la cellule (1,4). Cette cellule doit ensuite trouver une place pour fuir. Elle a le choix entre les cellules (1,3) et (2,4) car ces cellules sont dans le bloc mais ne sont données dans l'énoncé. Considérons le choix de la cellule (1,3). \\
	Nous arrivons ainsi au sudoku suivant avec en rouge la cellule agressé et en vert la cellule ou elle fuis. \\
		
	\begin{center}
         \begin{tabular}{|c|c| |c|c| }
               \hline
               \textbf{1}&2&{\color{green} 1}&{\color{red} 3}\\
               \hline
               3&4&\textbf{2}&4\\
               \hline
               \hline
               4&1&2&3\\
               \hline
               2&\textbf{3}&1&\textbf{4}\\                      
            \hline
        \end{tabular}
    \end{center}
    
    Les cellules (1,4) et (1,3) vont ainsi changer leur numéro. La colonne 4 n'étant toujours pas satisfaite il faut qu'elle choisisse un nouveau gêneur, cette fois ci il n'y a plus de choix il s'agit de la cellule (2,4). Cette cellule est agressé. Elle va choisir de fuir en (1,4) nous avons donc le nouveau sudoku suivant : \\
    \begin{center}
         \begin{tabular}{|c|c| |c|c| }
               \hline
               \textbf{1}&2& 3&{\color{green} 1}\\
               \hline
               3&4&\textbf{2}&{\color{red} 4}\\
               \hline
               \hline
               4&1&2&3\\
               \hline
               2&\textbf{3}&1&\textbf{4}\\                      
            \hline
        \end{tabular}
    \end{center}

    De même nous continuons, la cellule (1,4) est agressée. Elle choisis de fuir en (1,3) \\
	\begin{center}
         \begin{tabular}{|c|c| |c|c| }
               \hline
               \textbf{1}&2&{\color{green} 3}&{\color{red} 4}\\
               \hline
               3&4&\textbf{2}&1\\
               \hline
               \hline
               4&1&2&3\\
               \hline
               2&\textbf{3}&1&\textbf{4}\\                      
            \hline
        \end{tabular}
    \end{center}
    
    Enfin, la colonne 4 sera satisfaite quand la cellule(3,4) sera agressée et choisira de fuir en (3,3) \\
    \begin{center}
         \begin{tabular}{|c|c| |c|c| }
               \hline
               \textbf{1}&2&4&3\\
               \hline
               3&4&\textbf{2}&1\\
               \hline
               \hline
               4&1&{\color{green} 2}&{\color{red} 3}\\
               \hline
               2&\textbf{3}&1&\textbf{4}\\                      
            \hline
        \end{tabular}
    \end{center}

	Nous arrivons ainsi à la grille résolue suivante :\\

    	\begin{center}
         \begin{tabular}{|c|c| |c|c| }
               \hline
               \textbf{1}&2&4&3\\
               \hline
               3&4&\textbf{2}&1\\
               \hline
               \hline
               4&1&3&2\\
               \hline
               2&\textbf{3}&1&\textbf{4}\\                      
            \hline
        \end{tabular}
    \end{center}        
    
        \subsection{Diagramme de séquence}
            \subsubsection{SeSatisfaire}
                \begin{center}
                    \includegraphics[scale=0.7]{diagrams/sequenceEcoResolution1.png}
                \end{center} 
                Pour se satisfaire un éco-agent agresse tous les autres agents qui le gênent. Une fois qu'il n'est plus gêné il est satisfait. 
            \subsubsection{Fuir}
                \begin{center}
                    \includegraphics[scale=0.7]{diagrams/sequenceEcoResolution2.png}
                \end{center} 
                Si un agent doit fuir et qu'il est satisfait il devient non satisfait. Ensuite il recherche une place pour fuir, agresse tous les gêneurs qui l'empêche de fuir puis fait fuite. 
